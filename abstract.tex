\section*{Abstract}
One reason why containers, such as Docker and LinuxKit, are so widely used is because of the perceived isolation 
and security they provide against the potentially malicious user programs running inside of them. 
Yet, most container security measures are not designed to protect against zero-day bugs found inside the kernel itself. 
These bugs overwhelmingly ($\sim$94\%) appear in lines of code outside of the kernelâ€™s \textbf{\textit{popular paths}}. 
A reliable method for separating the popular from the unpopular paths within a kernel would provide a strong basis for the design of a more secure system. 
But, even if such a method can be found,  to truly be effective, kernel developers would need more information about previous code executions in these risky paths.

In this paper, we present a multi-step methodology for implementing a novel kernel forensic auditing system based on captured code execution data from widely-used container applications.  
The system gathers data from running container applications using a tailored kernel that logs each time a potentially risky (i.e., not popular) path is reached. 
The logged data is stored, updated and indexed using a novel data structure called \textbf{\textit{SmashPAK}}. 
If a kernel developer or system administrator wants to audit a container for a specific CVE vulnerability, 
the SmashPAK data structure can be searched in as little as a few milliseconds to learn if (and when) that bug  could have been triggered at a particular location. 
Both SmashPAK and the logging kernel, known as \textbf{\textit{UnPAK}}, are able to operate with minimal impact on the host containers. 
When tested running a number of real-world containers, UnPAK was able to operate with only minor increments (0.1\% on average) in runtime overhead, and only around 0.37\% extra cost in memory space.